---
phase: 04-performance-accessibility
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - components/portfolio/fluid-background.tsx
autonomous: true

must_haves:
  truths:
    - "WebGL context loss nao deixa canvas preto - componente recupera automaticamente"
    - "Mobile devices usam pixel ratio maximo de 1.5 para manter 60fps"
    - "Desktop devices usam pixel ratio maximo de 2"
    - "Shader usa mediump precision para melhor performance em mobile"
  artifacts:
    - path: "components/portfolio/fluid-background.tsx"
      provides: "Componente com context loss handling e adaptive DPR"
      contains: "webglcontextlost"
  key_links:
    - from: "components/portfolio/fluid-background.tsx"
      to: "canvas.addEventListener"
      via: "context loss event listeners"
      pattern: "webglcontextlost"
    - from: "fragmentShader"
      to: "precision mediump"
      via: "shader precision directive"
      pattern: "precision mediump float"
---

<objective>
Implementar WebGL context loss/restore handling e adaptive resolution scaling para manter 60fps em dispositivos mid-range.

Purpose: Performance e resiliencia - dispositivos mobile precisam de resolution scaling para manter 60fps, e context loss (comum em mobile/laptop) deve recuperar automaticamente.
Output: FluidBackground com context handlers, adaptive pixel ratio, e shader otimizado com mediump precision.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-performance-accessibility/04-RESEARCH.md
@.planning/phases/04-performance-accessibility/04-01-SUMMARY.md

@components/portfolio/fluid-background.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WebGL context loss/restore handlers</name>
  <files>components/portfolio/fluid-background.tsx</files>
  <action>
Add context loss and restore event handlers inside the useEffect:

1. After creating the renderer, add state tracking:
```typescript
let contextLost = false
```

2. Create handler functions:
```typescript
function handleContextLost(event: Event) {
  event.preventDefault() // CRITICAL - enables restore event
  contextLost = true
  cancelAnimationFrame(animationId)
}

function handleContextRestored() {
  contextLost = false
  // Renderer auto-restores in Three.js, just resume animation
  animate()
}
```

3. Add event listeners after creating renderer:
```typescript
const canvas = renderer.domElement
canvas.addEventListener("webglcontextlost", handleContextLost, false)
canvas.addEventListener("webglcontextrestored", handleContextRestored, false)
```

4. Update animate() function to check contextLost:
```typescript
function animate() {
  if (contextLost) return
  // ... existing animation code ...
}
```

5. Add cleanup in return function:
```typescript
canvas.removeEventListener("webglcontextlost", handleContextLost)
canvas.removeEventListener("webglcontextrestored", handleContextRestored)
```

Key point: event.preventDefault() in contextlost handler is REQUIRED - without it, restore event never fires.
  </action>
  <verify>
1. Run `bun run build` - should pass
2. In Chrome DevTools console, simulate context loss:
   `document.querySelector('canvas').getContext('webgl2').getExtension('WEBGL_lose_context').loseContext()`
3. Canvas should NOT go permanently black
4. After ~3 seconds, restore context:
   `document.querySelector('canvas').getContext('webgl2').getExtension('WEBGL_lose_context').restoreContext()`
5. Animation should resume
  </verify>
  <done>
WebGL context loss e tratado com event.preventDefault() e animation pause. Context restore retoma animacao automaticamente. Canvas nunca fica permanentemente preto.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement adaptive pixel ratio and mediump shader</name>
  <files>components/portfolio/fluid-background.tsx</files>
  <action>
1. Create getAdaptivePixelRatio helper function BEFORE the component:
```typescript
function getAdaptivePixelRatio(): number {
  const dpr = window.devicePixelRatio || 1
  // Mobile: cap at 1.5 for performance
  const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent)
  if (isMobile) {
    return Math.min(dpr, 1.5)
  }
  // Desktop: cap at 2
  return Math.min(dpr, 2)
}
```

2. Replace the existing setPixelRatio line:
```typescript
// OLD:
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2))

// NEW:
renderer.setPixelRatio(getAdaptivePixelRatio())
```

3. Update fragmentShader precision directive (first line after opening backtick):
```glsl
// OLD:
precision highp float;

// NEW:
#ifdef GL_ES
precision mediump float;
#else
precision highp float;
#endif

// Keep uTime as highp to prevent precision loss over time
uniform highp float uTime;
```

4. Remove `precision highp float;` from the old location and add the conditional precision at the top of fragmentShader.

Note: mediump is sufficient for all our calculations (UV coords, noise values, colors are all 0-1 range). Only uTime needs highp to prevent precision drift after hours of runtime.
  </action>
  <verify>
1. Run `bun run build` - should pass
2. On desktop, check renderer.getPixelRatio() returns <= 2
3. Shader should compile without errors (check console for WebGL warnings)
4. Animation should still render correctly with mediump
  </verify>
  <done>
Pixel ratio adaptado: mobile max 1.5, desktop max 2. Shader usa mediump por default (exceto uTime que usa highp para evitar precision loss). Performance em mobile deve melhorar significativamente.
  </done>
</task>

</tasks>

<verification>
- [ ] `bun run build` passa sem erros
- [ ] Context loss simulado e recuperado automaticamente
- [ ] Mobile devices usam DPR <= 1.5
- [ ] Desktop devices usam DPR <= 2
- [ ] Shader compila sem warnings WebGL
- [ ] Animacao roda smooth em desktop e mobile
</verification>

<success_criteria>
1. WebGL context loss nao causa canvas preto permanente - animacao retoma automaticamente
2. Dispositivos mobile usam pixel ratio limitado a 1.5 para manter 60fps
3. Shader usa mediump precision para melhor performance em GPUs mobile
4. Nenhuma regressao visual ou de comportamento
</success_criteria>

<output>
After completion, create `.planning/phases/04-performance-accessibility/04-02-SUMMARY.md`
</output>
